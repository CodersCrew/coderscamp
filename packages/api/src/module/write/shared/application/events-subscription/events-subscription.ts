/* eslint-disable no-await-in-loop */
import { Logger } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { PrismaClient } from '@prisma/client';
import { retry, RetryConfig, wait } from 'ts-retry-promise';

import { ApplicationEvent } from '@/module/application-command-events';
import { DomainEvent } from '@/module/domain.event';
import { PrismaService } from '@/prisma/prisma.service';
import { EventRepository } from '@/write/shared/application/event-repository';

import { OrderedEventQueue } from './ordered-event-queue';

export type EventsSubscriptionConfig = {
  readonly options: SubscriptionOptions;
  readonly positionHandlers: PositionHandler[];
  readonly eventHandlers: ApplicationEventHandler[];
};

type SubscriptionRetriesConfig = Pick<RetryConfig<unknown>, 'retries' | 'delay' | 'backoff'>;
type SubscriptionStartOptions = { from: { globalPosition: number } };
type SubscriptionQueueOptions = { maxRetryCount: number; waitingTimeOnRetry: number };

export type SubscriptionOptions = {
  start: SubscriptionStartOptions;
  queue: SubscriptionQueueOptions;
  retry?: SubscriptionRetriesConfig;
};

export type PrismaTransactionManager = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>;

export type OnEventFn<DomainEventType extends DomainEvent = DomainEvent> = (
  event: ApplicationEvent<DomainEventType>,
  context: { transaction: PrismaTransactionManager },
) => Promise<void> | void;

export type ApplicationEventHandler = {
  readonly eventType: string;
  readonly onEvent: OnEventFn;
};

export type OnPositionFn = (
  position: number,
  context: { transaction: PrismaTransactionManager },
) => Promise<void> | void;

export type PositionHandler = {
  readonly position: number;
  readonly onPosition: OnPositionFn;
};

export type SubscriptionId = string;

/**
 * EventsSubscription will receive all events published from EventRepository.
 * Published events have property globalOrder generated by auto-increment db field.
 * You can register handlers to be run or certain event.type or event.globalOrder.
 * Implementation is currently coupled with Prisma (support transactional - atomic event processing and moving subscription position) as database client and EventEmitter2 as event bus.
 * Subscription position is a globalOrder of last successfully processed event.
 */
export class EventsSubscription {
  private readonly logger = new Logger(EventsSubscription.name);

  private readonly eventsRetryCount = new Map<string, number>();

  private readonly queue = new OrderedEventQueue();

  private readonly eventEmitterListener: (_: unknown, event: ApplicationEvent) => void = (
    _: unknown,
    event: ApplicationEvent,
  ) => {
    return this.queue.push(event);
  };

  constructor(
    readonly subscriptionId: SubscriptionId,
    private readonly configuration: EventsSubscriptionConfig,
    private readonly prismaService: PrismaService,
    private readonly eventRepository: EventRepository,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  /**
   * Run subscription in two steps:
   *    1.  CatchUp - it's a processing during subscription processing all events which have occurred in the past (before start() invocation).
   *        Assuming that currentPosition of subscription is 10, and last event globalOrder is 15, then subscription will process events 11,12,13,14 and 15.
   *    2.  Listen - after catchup phase, the subscription will start listening for new events (with global order greater than 15).
   * After event handled event, subscription currentPosition is increased. There is strong transactional consistency for event handling and moving subscription position.
   * See handleEvent for more details how handling event working.
   */
  async start(): Promise<void> {
    const retryConfig = this.configuration.options?.retry ?? {
      retries: 'INFINITELY',
      backoff: 'EXPONENTIAL',
      delay: 3000,
    };

    // TODO: extract failure recovery to separeate module which will run in bootstrap phase (SRP)
    await retry(async () => {
      await this.catchUp().catch((e) => {
        this.logger.warn(`EventsSubscription ${this.subscriptionId} processing error in CatchUp phase.`, e);
        throw e;
      });
      this.listen().catch((e) => {
        this.logger.warn(`EventsSubscription ${this.subscriptionId} processing error in listen phase.`, e);
        throw e;
      });
    }, retryConfig).catch((e) =>
      this.logger.error(
        `EventsSubscription ${this.subscriptionId} stopped processing of events after ${retryConfig.retries} retries.`,
        e,
      ),
    );
  }

  /**
   * Stops listening for new events.
   */
  async stop(): Promise<void> {
    this.eventEmitter.offAny(this.eventEmitterListener);
    this.queue.stop();
  }

  /**
   * Stops processing.
   * Reset currentPosition to initialPosition.
   * Start processing from initialPosition.
   */
  async reset(): Promise<void> {
    await this.stop();
    this.queue.clear();
    await this.moveCurrentPosition(this.configuration.options.start.from.globalPosition - 1, this.prismaService);
    await this.start();
  }

  private async listen(): Promise<void> {
    this.eventEmitter.onAny(this.eventEmitterListener);

    let event = await this.queue.pop();

    while (!OrderedEventQueue.isStopToken(event)) {
      if (await this.globalOrderIsPreserved(event)) {
        await this.handleEvent(event);
      } else {
        await this.retryWithWaitingForCorrectOrder(event);
      }

      event = await this.queue.pop();
    }
  }

  private async globalOrderIsPreserved(event: ApplicationEvent): Promise<boolean> {
    // TODO this query can be optimized by tracking currentPosition inside listen() while loop
    const subscriptionState = await this.prismaService.eventsSubscription.findUnique({
      where: { id: this.subscriptionId },
    });
    const currentPosition =
      subscriptionState?.currentPosition ?? this.configuration.options.start.from.globalPosition - 1;

    const expectedEventPosition = currentPosition + 1;

    return event.globalOrder === expectedEventPosition;
  }

  private async catchUp(): Promise<void> {
    const subscriptionState = await this.prismaService.eventsSubscription.findUnique({
      where: { id: this.subscriptionId },
    });
    const eventsToCatchup = await this.eventRepository.readAll({
      fromGlobalPosition: subscriptionState?.currentPosition
        ? subscriptionState.currentPosition + 1
        : this.configuration.options.start.from.globalPosition,
    });

    // eslint-disable-next-line no-restricted-syntax
    for (const event of eventsToCatchup) {
      await this.handleEvent(event);
    }
  }

  /**
   * Handle event sequentially one after another by mean of queue pattern.
   * Handling an event is an atomic operation. While handling:
   *  - Run position handlers for handling event.globalOrder. Initial position handler is usable for preparing initial state of read model while resetting subscription associated with the read model.
   *  - Run event handlers for handling event.type.
   *  - Move subscription current position to event.globalOrder.
   *
   *  @throws Error if projection missed some event (for example: currentPosition is 5, but received event with globalOrder 7 instead of 6).
   */
  private async handleEvent<DomainEventType extends DomainEvent>(
    event: ApplicationEvent<DomainEventType>,
  ): Promise<void> {
    this.eventsRetryCount.delete(event.id);

    try {
      // TODO add transaction
      await this.processSubscriptionPositionChange(event, this.prismaService);
      await this.processEvent(event, this.prismaService);
      await this.moveCurrentPosition(event.globalOrder, this.prismaService);
    } catch (e) {
      await this.stop();
      this.logger.warn(
        `EventsSubscription ${this.subscriptionId} processing stopped on position ${event.globalOrder}`,
        e,
      );
      throw e;
    }
  }

  async retryWithWaitingForCorrectOrder(event: ApplicationEvent): Promise<void> {
    // TODO cancel wait when subscriber recive stop signal
    const count = this.eventsRetryCount.get(event.id) ?? 0;

    if (count >= this.configuration.options.queue.maxRetryCount) {
      throw new Error(
        `EventsSubscription ${this.subscriptionId} missed some events! MaxRetryCount reached on event(${event.id}) with globalOrder(${event.globalOrder})`,
      );
    }

    this.queue.push(event);
    this.eventsRetryCount.set(event.id, count + 1);
    await wait(this.configuration.options.queue.waitingTimeOnRetry);
  }

  private async processEvent(event: ApplicationEvent, transaction: PrismaTransactionManager) {
    await Promise.all(
      this.configuration.eventHandlers
        .filter((handler) => handler.eventType === event.type)
        .map((handler) => handler.onEvent(event, { transaction })),
    );
  }

  private async processSubscriptionPositionChange(event: ApplicationEvent, transaction: PrismaTransactionManager) {
    await Promise.all(
      this.configuration.positionHandlers
        .filter((handler) => handler.position === event.globalOrder)
        .map((handler) => handler.onPosition(event.globalOrder, { transaction })),
    );
  }

  private async moveCurrentPosition(position: number, transaction: PrismaTransactionManager) {
    await transaction.eventsSubscription.upsert({
      where: {
        id: this.subscriptionId,
      },
      create: {
        id: this.subscriptionId,
        eventTypes: this.handlingEventTypes(),
        fromPosition: this.configuration.options.start.from.globalPosition,
        currentPosition: position,
      },
      update: {
        currentPosition: position,
        eventTypes: this.handlingEventTypes(),
      },
    });
  }

  private handlingEventTypes() {
    return this.configuration.eventHandlers.map((h) => h.eventType);
  }
}
